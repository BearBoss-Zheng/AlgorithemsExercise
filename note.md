day01知识点汇总：  
            时间复杂度       空间复杂度       是否稳定  
选择排序        o(n²)           o(1)          ❌  
冒泡排序        o(n²)           o(1)           ✔  
插入排序        o(n²)           o(1)           ✔  
希尔排序        o(n²)           o(1)           ❌  
归并排序        o(nlogn)        o(n)           ✔  
快速排序        o(nlogn)        o(logn)        ❌  
堆排序          o(nlogn)        o(1)           ❌  
基数排序        o(d * (n+k))    o(n+k)         ✔  
    d是最大数字的位数，n是元素个数，k是基数  
  
  
day02知识点  
1. 亦或 :  
   0 ^ n = n  
   n ^ n = 0  
2. 原码、补码、反码  
   计算机中使用的都是补码  
    正数： 原码 = 反码 = 补码  
    负数： 反码 = 原码所有位取反；  
          补码 = 反码 + 1  
3. 找到 x 中最右边的 1 所在的位置  
    （1）xorResult & -xorResult;  
    （2）x & (~x + 1)   
    两个式子其实是等价的，~x + 1 就是 -xorResult，  
    因为是相反数的补码，所以要先取反，然后加1  
  
day03知识点：  
1. 二叉树的遍历：  
    深度优先遍历（depth-first traversal）：前序、中序、后序遍历  
    宽度优先遍历（breadth-first traversal）：从树的根节点出发，首先访问该节点，然后一次访问其相邻的  
        节点，接着是这些相邻节点的相邻节点，以此类推，直到遍历完整个结构。  
  
2. 二叉树的类别：  
       ①【搜索二叉树（Binary Search Tree）】  
          搜索二叉树（Binary Search Tree，BST）是一种二叉树的特殊形式，具有以下性质：  
          （1）对于树中的每个节点，其左子树中的每个节点的值都小于该节点的值。  
          （2）对于树中的每个节点，其右子树中的每个节点的值都大于该节点的值。  
          （3）左右子树都是搜索二叉树。  
                  10  
                 /  \  
                5   15  
               / \    \  
              3   7    20   
       ②【完全二叉树（Complete Binary Tree）】  
          叶子节点指挥出现再最后2层，且最后一层叶子节点都靠左对齐  
                   10  
                  /  \  
                 5   15  
                / \  
               3   7   
       ③ 【满二叉树（Full Binary Tree）】  
          满二叉树是特殊的完全二叉树，其中每个节点要么没有子节点，要么有两个子节点，  
          且所有叶子节点都在同一层。  
                  1  
                 / \  
                2   3  
               / \ / \  
              4  5 6  7  
       ④ 【平衡二叉树（Balanced Binary Tree）】  
          平衡二叉树（Balanced Binary Tree），又称为 AVL 树，具有以下性质：  
          （1）对于树中的每个节点，它的左子树和右子树的高度差不能超过1。  
          （2）左子树和右子树都必须是平衡二叉树。  
                   10  
                  /  \  
                 5   15  
                / \  
               3   7  

3.
  
day04知识点：  
1. HashMap的特性：  
   HashMap 的基于哈希表的实现提供了常数时间复杂度的查找、插入和删除操作，  
   即 O(1) 的平均时间复杂度。但在极端情况下，比如哈希冲突较多时，最坏情况下可能会达到 O(n) 
2. 并查集数据结构  
   并查集（Disjoint Set Union，简称DSU），也被称为Union-Find或并查集树，  
   是一种用于处理集合合并和查找问题的数据结构。并查集主要支持两种操作：合并（Union）和查找（Find）。  
   [主要思想]：  
   (1)初始化： 开始时，每个元素各自属于一个独立的集合，每个集合只包含一个元素，即元素本身。  
   (2)查找（Find）： 通过递归或迭代，找到一个元素所属的集合（根节点，代表元素）。  
                 这可以用于判断两个元素是否属于同一集合。  
   (3)合并（Union）： 将两个集合合并为一个集合。找到两个元素所属集合的代表元素，  
                 然后将其中一个的代表元素的父节点指向另一个的代表元素，从而实现合并。  
3. KMP算法   
   KMP算法（Knuth-Morris-Pratt算法）是一种用于在文本串中查找子串的高效字符串匹配算法。
   它的主要思想是利用已经匹配过的信息，尽量减少不必要的字符比较KMP算法的核心是构建一个部分匹配表（Partial Match Table）  
   简称PMTable或者Next数组。这个表告诉我们，在匹配过程中如果出现不匹配的情况，应该将模式串向右移动多少位，而不是简单地
   将模式串移动一位。
   有一张我画的图，有助于理解，见./pic/kmp.jpg  
   具体步骤如下： 
   （1）构建部分匹配表： 
   从模式串的第一个字符开始，对于每个位置，计算其前缀和后缀的最长公共部分长度。 
   将这个长度填入部分匹配表中对应位置。 
   （2）在匹配时使用部分匹配表： 
   当发生不匹配时，根据部分匹配表的值，移动模式串，使得模式串的某个前缀和文本串的当前位置对齐。 
   这样，KMP算法避免了在文本串中的每个可能位置都重新比较所有字符，提高了匹配的效率。 
 
day05
1. Manacher算法  
   Manacher算法是一种用于查找最长回文子串的线性时间复杂度算法。  
   【核心思想】  
   该算法的核心思想是利用回文串的对称性，避免重复计算。它通过在字符串中插入特殊字符（通常是#）  
   来处理奇偶长度的回文串，然后利用已知的回文串信息来加速寻找新的回文串。  
   【步骤如下】  
   abc -> #a#b#c#  
   cur 表示当前的节点    
   pre 表示前一个节点，L表示前一个节点最长回文字串的左边界，R为右边界    
   sym(symmetric)表示 以pre为原点，cur的对成点  
   利用回文字串的对成性，可以简化算法如下： 
   1.cur > R  
   直接暴力外扩，往外面一步步扩张，找回文串，最原始的方法  
   2.cur <= R  
   ① sym的左边界在 L 内，那么pal[cur] = pal[sym]  
   ② sym的左边边界就是 L ，那么cur可以往外再找找，因为pal[cur] 有可能突破R  
   ③ sym的左边界超过了 L ，那么pal[cur] = (R-cur)*2 +1 、  
   ./pic/manacher.jpg 可进一步帮助理解 ③  
   【注意】  
    pal里面填写回文半径，更方便回文长度的计算
2. 窗口问题  
    利用双端队列维护，保持严格的单调减。队列当中维护的是坐标，方便根据窗口大小处理过期数据。  

